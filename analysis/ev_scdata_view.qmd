---
title: "Single cell perspective into Extracellular Vesicules"
format:
  html:
    code-fold: true
    code-tools: true
    embed-resources: true
    self-contained-math: true
jupyter: python3
---

# Load in data

Set up the environment and load the deps:

```{python}
#| output: false

import re
import pandas as pd
pd.set_option('display.max_columns', 100)
import scanpy as sc
import anndata as an
import numpy as np
import seaborn as sns
import seaborn.objects as so
import matplotlib.pyplot as plt
from scipy.stats import kruskal
from scipy.stats import pearsonr
from pathlib import Path
from os import getenv
from dotenv import load_dotenv
from os.path import expanduser

## load the environment variables from the .env file
load_dotenv()

anndata_folder = getenv("ANNDATA_FOLDER")
atlas_folder = getenv("ATLAS_FOLDER")
data_folder = getenv("DATA_FOLDER")
raw_data_folder = getenv("RAW_DATA_FOLDER")
snapshot_an_loc = Path(data_folder).expanduser() / "sc_deconv_snapshot.h5ad"

```

Load in the HECA dataset.

```{python}
#| output: false

## load in the modified HECA atlas
sc_dat = an.read_h5ad(snapshot_an_loc)

```

Load in the bulk data from the EV and biopsy samples

```{python}

## load in the EV data
comb_uf_mat = pd.read_feather(Path(data_folder).expanduser() / "combined" / "comb_uf_tpm.feather").set_index("gene_id").iloc[:-1]
comb_uf_pheno = pd.read_table(Path(data_folder).expanduser() / "combined" / "comb_uf_pheno.tsv").set_index("samplename")
comb_uf_raw = pd.read_feather(Path(data_folder).expanduser() / "combined" / "comb_uf.feather").set_index("gene_id").iloc[:-1]
## and reformat and join the data into long data (for better visuals)
comb_uf = (
  comb_uf_mat
  .transpose()
  .rename(columns={"gene_id": "samplename"})
  .join(comb_uf_pheno, how="inner")
  .melt(
    id_vars=comb_uf_pheno.columns.to_list(),
    var_name="gene_id",
    value_name="norm_expr"
    )
)

clin_de_genes = pd.read_table(Path(data_folder).expanduser() / "clin_de_genes.tsv").locus.to_list()
uf_bio_genes = pd.read_table(Path(data_folder).expanduser() / "combined" / "uf_bio_genes.tsv").locus.to_list()

## load in the SCRATCH clinical bio data
scratch_mat = pd.read_feather(Path(raw_data_folder).expanduser() / "star_mat_pheno.feather").set_index("sample")
cols_to_keep = ["HID", "ages", "Timing_LH", "status_rif", "no_lb"]
scratch_pheno = scratch_mat[cols_to_keep]
scratch_mat = (
  scratch_mat
  .drop(columns=cols_to_keep)
  .transpose()
  .rename_axis("gene_id")
  .infer_objects()
  .iloc[:-1]
)

## load in the EV CCHT only data
ccht_uf_raw = pd.read_feather(Path(data_folder).expanduser() / "filtered" / "annot_raw.feather").set_index("gene_id").iloc[:-1]
ccht_uf_pheno = (
  pd.read_table(Path(data_folder).expanduser() / "filtered" / "phenotype.tsv")
  .set_index("samplename")
  .query("samplename in @ccht_uf_raw.columns")
  .assign(
    cyclephase=lambda x: 
      pd.Categorical(x.cyclephase, categories=["pro", "pre", "rec", "post"], ordered=True)
    )
)

## load in clinical samples
clin_uf_raw = pd.read_feather(Path(data_folder).expanduser() / "clin_counts_raw.feather").iloc[:-1]
clin_uf_pheno = pd.read_table(Path(data_folder).expanduser() / "phenotype_clin.tsv").set_index("samplename")
clin_uf_pheno = clin_uf_pheno.query("samplename in @clin_uf_raw.columns")
## change the gene_id for the clinical samples
annot = pd.read_csv(Path(raw_data_folder).expanduser() / "annot_table.csv")
clin_uf_raw = (
  clin_uf_raw
  .merge(annot, left_on='gene_id', right_on='ensembl_gene_id')
  .drop(["ensembl_gene_id", "description", "gene_id"], axis=1)
  .groupby("external_gene_name")
  .sum()
)
clin_uf_raw.index.name = "gene_id"
clin_uf_raw = clin_uf_raw.loc[:, clin_uf_pheno.index]

```

# General stats

Check out the number of cells in each dataset with the origin of the cell.

```{python}
sns.displot(sc_dat.obs, x="dataset", hue="Stage", multiple="stack").set_xticklabels(rotation=90)
```

Or just comparison between celltypes in different HECA datasets

```{python}
g = sns.displot(sc_dat.obs, x="dataset", hue="celltype", multiple="stack").set_xticklabels(rotation=90)
sns.move_legend(g, "center right", fancybox=True, ncol=2, bbox_to_anchor=(1.25,0.5))
```

How many different classes of biopsy types there are in the whole dataset?

```{python}
sns.displot(
  sc_dat.obs[["samplename", "Biopsy_type"]].drop_duplicates(),
  x="Biopsy_type"
  ).set_xticklabels(rotation=90)
```

# Biomarker expression through cyclephases in scRNA-seq

## Statistical testing on the biogenesis genes

Here we will perform a statistical test on the expression of the ESCRT genes in the different cycle phases. We will use the Kruskal-Wallis test to check if there is a significant difference between the groups. Additionally, we will use pearson's rank correlation to check if there is a correlation between the expression of the genes and the cycle phase, which is coded into a dummy variable (0 - proliferative, 1 - early-secretory, 2 - mid-secretory, 3 - late-secretory).

```{python}
## define a function for the data extraction
def gene_x_sample_view(
  sc_dat_obj, 
  gene_list=["TBX15", "ERICH3", "SNTN", "WDR38", "CD33", "COL9A1", "IDHA1", "SPDEF", "CDKN2A"],
  cols_of_interest={"index", "Age", "lineage", "celltype"}
  ):
  ## read in the genelist and select the genes in sc_dat_obj
  sc_dat_obj = sc_dat_obj[:, sc_dat_obj.var.index.isin(gene_list)].to_memory()
  ## and merge with the obs table and pivot the gene table
  return (
    sc_dat_obj.obs.join(
      pd.DataFrame(
        sc_dat_obj.X.toarray(),
        index=sc_dat_obj.obs.index,
        columns=sc_dat_obj.var.index
      ),
      how="left"
    )
    .reset_index()
    .melt(
      id_vars=cols_of_interest, 
      value_vars=set(sc_dat_obj.var.index),
      var_name="gene_id",
      value_name="norm_expr"
      )
    .set_index("index")
  )

def normalize_expr_by_cell_count(df_from_gene_view):
  """
  Normalizes the 'norm_expr' column of a DataFrame (output of gene_x_sample_view)
  by the number of unique cells within each celltype and cyclephase group.

  The input DataFrame is expected to have an index named 'index' (cell ID),
  and columns 'norm_expr', 'celltype', and 'cyclephase'.

  Args:
    df_from_gene_view (pd.DataFrame): DataFrame, typically from gene_x_sample_view.

  Returns:
    pd.DataFrame: The DataFrame with an added column 'norm_expr_by_cell_count'.
  """
  # Validate required columns and index name
  if not {'celltype', 'cyclephase'}.issubset(df_from_gene_view.columns):
    raise ValueError("Input DataFrame must contain 'celltype' and 'cyclephase' columns.")
  if df_from_gene_view.index.name != 'index':
    # If this error occurs, it means the assumption about gene_x_sample_view's output index name is wrong
    # or the input df is not directly from gene_x_sample_view.
    raise ValueError("Input DataFrame must have an index named 'index' (representing cell ID).")

  # Reset index to use cell ID ('index' column) in operations
  df_reset = df_from_gene_view.reset_index() # Cell IDs are now in a column named 'index'

  # Determine unique cells and their 'celltype' and 'cyclephase'
  # The 'index' column in df_reset contains the cell identifiers.
  unique_cells_df = df_reset[['index', 'celltype', 'cyclephase']].drop_duplicates()

  # Calculate the number of unique cells for each (celltype, cyclephase) combination
  # Using observed=True is good practice if 'celltype' or 'cyclephase' are categorical
  cell_counts = (
    unique_cells_df.groupby(['celltype', 'cyclephase'], observed=True)['index']
    .count()
    .rename('num_cells_in_group')
    .reset_index() # Convert grouped output back to DataFrame
  )
  
  # Merge these counts back to the main data
  df_merged = pd.merge(df_reset, cell_counts, on=['celltype', 'cyclephase'], how='left')
  
  # Calculate the normalized expression
  # This creates a new column; it does not overwrite 'norm_expr'
  df_merged['norm_expr_by_cell_count'] = df_merged['norm_expr'] / df_merged['num_cells_in_group']
  
  # Restore the original index (the cell ID column, named 'index')
  df_final = df_merged.set_index('index')
      
  return df_final


## Create a dictionary of all the genes we want to plot
all_genes = {
  "ESCRT-0": ["HGS", "STAM", "STAM2"],
  "ESCRT-I": ["MVB12A", "MVB12B", "TSG101", "UBAP1", "VPS28", "VPS37A", "VPS37B", "VPS37C", "VPS37D"],
  "ESCRT-II": ["SNF8", "VPS25", "VPS36"],
  "ESCRT-III": ["CHMP2A", "CHMP2B", "CHMP3", "CHMP4A", "CHMP4B", "CHMP4C", "CHMP6"],
  "ESCRT-IV": ["VPS4A","VPS4B","VTA1"],
  "ESCRT-independent": ["RAB31", "SMPD3"],
  "EV release gene markers": ["RAB27A", "RAB27B", "RAB11A", "RAB11B", "RAB3A", "RAB3B", "RAB3C", "RAB3D", "RAB7A", "RAB7B"],
  "tetraspanins": ["CD9", "CD63", "CD81", "ALIX", "SDCBP"],
  "accessory": ["PDCD6IP", "SDCBP", "SDC1", "SDC2", "SDC3", "SDC4"]
}

# Initialize a dictionary to store the DataFrames for each gene group.
extracted_gene_dfs = {}

# Iterate over each gene group defined in the all_genes dictionary.
for group_name, gene_list_for_group in all_genes.items():
  # Use the pre-defined gene_x_sample_view function to extract and format data
  df_group = gene_x_sample_view(
    sc_dat_obj=sc_dat,
    gene_list=gene_list_for_group,
    cols_of_interest={"index", "lineage", "celltype", "cyclephase"}
  )
  
  # Store the resulting DataFrame in the dictionary, keyed by the group name.
  extracted_gene_dfs[group_name] = df_group

df_group = normalize_expr_by_cell_count(df_group)
# Convert the dictionary of DataFrames into a single DataFrame.
all_gene_df = pd.concat(extracted_gene_dfs, names=['gene_group', 'index']).reset_index()
del extracted_gene_dfs
```

```{python}
#| df-print: paged
# Perform Kruskal-Wallis test to test significance of expression differences across cycle phases

def kruskal_wallis_test(df):
  # If all norm_expr values are identical for this gene/celltype, Kruskal-Wallis is not meaningful
  if df["norm_expr"].nunique() == 1:
    return pd.Series({"h_statistic": np.nan, "p_value": np.nan})

  # Group by cyclephase and get norm_expr for each group
  groups = [group["norm_expr"].values for name, group in df.groupby("cyclephase")]
  
  # Perform Kruskal-Wallis test if there are at least two groups to compare
  if len(groups) > 1:
    h_stat, p_val = kruskal(*groups)
    return pd.Series({"h_statistic": h_stat, "p_value": p_val})
  else:
    # Not enough groups to perform the test
    return pd.Series({"h_statistic": np.nan, "p_value": np.nan})

# Apply the test to each gene, celltype, and gene_group combination
kruskal_results = (
  all_gene_df
  .groupby(["gene_group", "gene_id", "celltype"]) # Added "gene_group" here
  .apply(kruskal_wallis_test)
  .reset_index()
  .dropna()
  .sort_values(by=["gene_group", "p_value", "gene_id"], ascending=[True, True, False])
  .assign(significant=lambda x: x["p_value"] < 0.05)
)

# Display as HTML table for better Quarto rendering
kruskal_results
```

```{python}
#| df-print: paged
# Perform Pearson's rank correlation test

# Define the cycle phases of interest and their numeric mapping.
# This aligns with plot_gene_list and the dummy variable description from the problem statement.
cycle_phases_for_correlation = ["EP", "ES", "MS", "LS"]
cycle_phase_to_numeric_map = {
  "EP": 0,  # Proliferative (Early)
  "ES": 1,  # Early-Secretory
  "MS": 2,  # Mid-Secretory
  "LS": 3   # Late-Secretory
}

# Filter `all_gene_df` for the relevant cycle phases.
# Create a numeric representation of cyclephase for correlation.
# Make a copy to avoid SettingWithCopyWarning on `all_gene_df`.
df_for_correlation = all_gene_df[all_gene_df['cyclephase'].isin(cycle_phases_for_correlation)].copy()

# Ensure 'cyclephase' is string type before mapping to handle potential categorical types correctly.
df_for_correlation['cyclephase'] = df_for_correlation['cyclephase'].astype(str)
df_for_correlation['cyclephase_numeric'] = df_for_correlation['cyclephase'].map(cycle_phase_to_numeric_map)

# Define the Pearson correlation test function
def pearson_correlation_test(df_group):
  # df_group contains 'cyclephase_numeric' and 'norm_expr' for a specific gene/celltype combination.
  
  # Prepare data for correlation: drop rows with NaNs in essential columns.
  # `norm_expr` might have NaNs if source data did; `cyclephase_numeric` should be clean due to pre-filtering and mapping.
  clean_df = df_group[['cyclephase_numeric', 'norm_expr']].dropna()

  # Check for sufficient data and variance after cleaning.
  # Pearson correlation requires at least 2 unique values for both variables and typically at least 3 data points.
  if clean_df['norm_expr'].nunique() < 2 or \
     clean_df['cyclephase_numeric'].nunique() < 2 or \
     len(clean_df) < 3:
    return pd.Series({'correlation_coefficient': np.nan, 'p_value': np.nan})
      
  # Perform Pearson correlation
  try:
    corr, p_val = pearsonr(clean_df['cyclephase_numeric'], clean_df['norm_expr'])
    return pd.Series({'correlation_coefficient': corr, 'p_value': p_val})
  except ValueError: 
    # This might occur in edge cases not caught by nunique/length checks (e.g., zero variance after cleaning).
    return pd.Series({'correlation_coefficient': np.nan, 'p_value': np.nan})

# Apply the Pearson correlation test to each group.
# Groups are defined by gene_group, gene_id, and celltype.
# `observed=True` is good practice for groupby with categorical data.
pearson_results = (
  df_for_correlation
  .groupby(["gene_group", "gene_id", "celltype"], observed=True) 
  .apply(pearson_correlation_test)
  .reset_index()
  .dropna()  # Remove rows where the test could not be performed (returned NaNs)
  .sort_values(by=["gene_group", "p_value", "gene_id"], ascending=[True, True, False])
  .assign(significant=lambda x: x["p_value"] < 0.05) # Add a significance flag
)

pearson_results
```

## The expression of the genes throughout the cycle

Here we first subset the single-cell atlas per following criteria:

* We filter out samples with "Whole Uterus" biopsy type
* Filter out celltypes marked as "dHormones", "eHormones" and "sHormones"

For gene comparison, we use the normalised counts from the scRNA-seq HECA dataset. These counts are normalised via Pearson residuals-based variance-stabilizing transformation [related article](https://www.nature.com/articles/s41592-023-01814-1#MOESM3).

Following this, well look at all the different cycle phases that are also represented in the UF dataset:

* EP or Early-Proliferative as "pro"/"Proliferative"
* LP or Late-Proliferative as "pro"/"Proliferative"
* ES or Early-Secretory as "pre"/"Pre-receptive"
* MS or Mid-Secretory as "rec"/"Receptive"
* LS or Late-Secretory as "post"/"Post-receptive"

```{python}

## create a plotting function for gene lists
def plot_gene_list(
  sc_dat, 
  gene_list, 
  wrap_rows=3,
  cycle_filt=["EP", "ES", "MS", "LS"],
  biopsy_type_filt=["Whole_Uterus"]
  ):
  sc_obs_tmp = gene_x_sample_view(
      sc_dat[
        sc_dat.obs
          .query("Biopsy_type not in @biopsy_type_filt & cyclephase in @cycle_filt")
          .index
      ],
      gene_list=gene_list,
      cols_of_interest={"index", "lineage", "celltype", "cyclephase"}
    ).assign(cyclephase=lambda x:
        x.cyclephase.astype("str").astype("category").cat.reorder_categories(cycle_filt, ordered=True)
    )

  ## precalculate stat
  return (
    so.Plot(
      (
        sc_obs_tmp
        .groupby(["gene_id", "cyclephase", "lineage"])
        .agg({"norm_expr": ['mean', 'min', 'max', 'sem']})
        .droplevel(0, axis=1)
        .reset_index()
        .assign(se_min=lambda x: x["mean"] - x["sem"], se_max=lambda x: x["mean"] + x["sem"])
      ),
      x="cyclephase",
      y="mean",
      ymin="se_min",
      ymax="se_max",
      color="lineage"
    )
    # .layout(size=(9,12))
    .add(so.Line())
    .add(so.Band(alpha=.2))
    .facet(None, "gene_id", wrap=wrap_rows)
    .share(y=False)
    .theme(sns.axes_style("white") | sns.plotting_context("notebook"))
  )

```

::: {.panel-tabset}

### Implantation DE

First lets look at the expression changes of **implantation or implantation failure DE genes** throughout the menstrual cycle for every major cell typ.

```{python}
plot_gene_list(sc_dat, clin_de_genes, wrap_rows=11)
```

### ESCRT-0

Then, we have ESCRT-0 complex markers to investigate: HGS, STAM, STAM2

```{python}
plot_gene_list(sc_dat, all_genes["ESCRT-0"], wrap_rows=2)
```

### ESCRT-I

ESCRT-I complex markers: MVB12A,MVB12B,TSG101,UBAP1,VPS28,VPS37A,VPS37B,VPS37C,VPS37D

```{python}
plot_gene_list(sc_dat, all_genes["ESCRT-I"], wrap_rows=3)
```

### ESCRT-II

ESCRT-II complex markers: SNF8, VPS25, VPS36

```{python}
plot_gene_list(sc_dat, all_genes["ESCRT-II"], wrap_rows=2)
```

### ESCRT-III

ESCRT-III complex markers: CHMP2A, CHMP2B, CHMP3, CHMP4A, CHMP4B, CHMP4C, CHMP6

```{python}
plot_gene_list(sc_dat, all_genes["ESCRT-III"], wrap_rows=3)
```

### ESCRT-IV

ESCRT-III complex markers: VPS4A,VPS4B,VTA1

```{python}
plot_gene_list(sc_dat, all_genes["ESCRT-IV"], wrap_rows=2)
```

### ESCRT-independent

ESCRT-independent EV-associated markers: RAB31, SMPD3 (nSMASE2)

```{python}
plot_gene_list(sc_dat, all_genes["ESCRT-independent"], wrap_rows=2)
```

### EV release gene markers

Variations of RAB27, RAB11, RAB3, RAB7, split into two groups for better visualisation

```{python}
# sc_dat.var.index[sc_dat.var.index.str.contains("RAB")]
gene_selection=all_genes["EV release gene markers"][:4]
plot_gene_list(sc_dat, gene_selection, wrap_rows=2)
```

```{python}
gene_selection=all_genes["EV release gene markers"][4:]
plot_gene_list(sc_dat, gene_selection, wrap_rows=3)
```

### Tetraspanins

Tetraspanins and other cargo markers: CD9, CD63, CD81, ALIX, SDCBP

```{python}
plot_gene_list(sc_dat, all_genes["tetraspanins"], wrap_rows=2)
```

### Accessory

Accessory markers PDCD6IP, SDCBP (syntenin-1), SDC (syndecan)

```{python}
plot_gene_list(sc_dat, all_genes["accessory"], wrap_rows=2)
```

### All the genes combined

Finally, we can look at all the genes combined. This is a bit of a mess, but it shows the expression of all the genes throughout the cycle.

```{python}

```

:::
