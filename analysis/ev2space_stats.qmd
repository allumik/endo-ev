---
title: "Single cell perspective into Extracellular Vesicules projected onto Spatial Transcriptomics"
format:
  html:
    code-fold: true
    code-tools: true
    embed-resources: true
    self-contained-math: true
jupyter: python3
---

# Load in data

Set up the environment and load the deps:

```{python}
#| output: false

import re
import os
import glob
import warnings
import pandas as pd
import numpy as np
import scanpy as sc
import squidpy as sq
import anndata as an
from pathlib import Path
from dotenv import load_dotenv
from scipy.sparse import csr_matrix
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import seaborn as sns

# pd.set_option('display.max_columns', 100)

## import the functions used in this report (got too long to include them in the report)
try: from analysis.helpers.projection_functions import *
except ImportError: from helpers.projection_functions import *

## load the environment variables from the .env file
load_dotenv()
if os.getenv("DATA_FOLDER") is None:
  load_dotenv(Path.cwd() / ".env")

anndata_folder = os.getenv("ANNDATA_FOLDER")
atlas_folder = os.getenv("ATLAS_FOLDER")
data_folder = os.getenv("DATA_FOLDER")
st_folder = os.getenv("ST_FOLDER")
model_folder = Path(data_folder).expanduser() / "saved_models"
raw_data_folder = os.getenv("RAW_DATA_FOLDER")

```

Load in the scRNA-seq data.

```{python}
#| output: false

## load in the modified HECA atlas
snapshot_an_loc = Path(data_folder).expanduser() / "sc_deconv_snapshot.h5ad"
sc_dat = an.read_h5ad(snapshot_an_loc)
general_cells = ( # associate celltypes with the lineage information in the sc_dat.obs
  sc_dat.obs
  .loc[:, ["lineage", "celltype"]]
  .drop_duplicates("celltype")
  .set_index("celltype", drop=True)
)
```


Load in the spatial slides experiments

```{python}
gen_sc_file = Path(anndata_folder).expanduser() / "gen_sc_ev.h5ad"
gen_ccht_ev = sc.read_h5ad(gen_sc_file, backed="r").to_memory()
gen_sc_file = Path(anndata_folder).expanduser() / "gen_sc_biopsy.h5ad"
gen_ccht_bio = sc.read_h5ad(gen_sc_file, backed="r").to_memory()
```

```{python}
# Load the data
data_directory = Path(anndata_folder).expanduser() # Current directory, adjust as needed
adata_collection = load_spatial_data(data_directory)
```


# Calculate summary statistics for the ST slides

Here we try to quantify the difference in distances of different enrichment signatures. For this, we calculate the following statistics:

* Per cell type over all the slides
  * Simple absolute difference of enrichment per spot
  * Correlation between slides via `scipy.signal.correlate2d`
  * Apply 2D filtering and then calculate the average distance to enrichment cluster on another projection
    * Try either mean or max filtering for the most enriched cell type
* General clustering statistics over all the slide
  * Moran's I which indicates the strength of clustering, here applied on celltype abundances with the `squidpy.gr.spatial_autocorr` function
  * Ripley's K-function on the maximum enrichment cell type, calculated via `squidpy.gr.ripley`
  * Jaccard Index compared to the `ref` slide after filtering enrichment scores with a lower quartile threshold
  * Total distance (Wasserstein distance?) per celltype over the whole slide per celltype

For the filtering step we wish to remove any lowly enriched clusters so that only the more highly expressed features are left. This step is also applied before the multiclass plots so that the lowly enriched values wouldnt affect the other cell types. The lowly enriched region filtering is performed via a simple thresholding approach where the threshold is the lower quartile of the distribution over the slide for the cell type.

In addition, we have subset some of the more niche celltypes that either don't exhibit a patterns in expression or are not related to the current cycle phase. Therefore, we will exclude endothelial cell types from the analysis, as it has only two main cell types (arterial and vascular). 

```{python}
## Run the functions on the dataset
jaccard_thresh = 0.25 # Use lower quartile for Jaccard and Centroid distance

# Process each slide
all_slides = [
  "152806", "152810", "152807", "152811"
  "CTR1_processed_data", "CTR2_processed_data", 
  "CTR3_processed_data", "CTR4_processed_data"
  ]
all_results = []
for slide_id in all_slides:
  print(f"Processing slide: {slide_id}")

  # Calculate Spatial Graph (once per slide, using ref adata)
  # Ensure graph calculation works even if previously calculated
  # Use generic coord_type for flexibility if not strictly Visium grid
  metricses = []
  for datatype in ["ref", "ev", "bio"]:
    # get it from the collection to run the spatial neighbors
    current_dataset = adata_collection.get((slide_id, datatype))
    sq.gr.spatial_neighbors(
      current_dataset,
      coord_type="generic",
      spatial_key="spatial",
      key_added="spatial"
    )
    # and set it back to the collection for later use
    adata_collection[(slide_id, datatype)] = current_dataset

    # Calculate Single-Adata Metrics (Moran's I) for each projection
    metrics_df = calculate_single_adata_metrics(current_dataset)
    metrics_df['comparison'] = datatype
    metricses.append(metrics_df)

  single_metrics = pd.concat(metricses, ignore_index=True)
  single_metrics['slide_id'] = slide_id
  # single_metrics['comparison'] = 'within_reference' # Indicate these are not pairwise comparisons
  all_results.append(single_metrics)

  # Calculate Pairwise Comparison Metrics for different comparisions
  comp_metrics_ev_vs_ref = calculate_comparison_metrics(
    adata_collection.get((slide_id, "ref")),
    adata_collection.get((slide_id, "ev")),
    jaccard_thresh
  )
  comp_metrics_ev_vs_ref['slide_id'] = slide_id
  comp_metrics_ev_vs_ref['comparison'] = 'ev_vs_ref'
  all_results.append(comp_metrics_ev_vs_ref)

  comp_metrics_bio_vs_ref = calculate_comparison_metrics(
    adata_collection.get((slide_id, "ref")),
    adata_collection.get((slide_id, "bio")),
    jaccard_thresh
  )
  comp_metrics_bio_vs_ref['slide_id'] = slide_id
  comp_metrics_bio_vs_ref['comparison'] = 'bio_vs_ref'
  all_results.append(comp_metrics_bio_vs_ref)

# Combine all results into a single DataFrame and add lineage mapping
all_results = (
  pd.concat(all_results, ignore_index=True)
  .rename(columns={"cell_type": "celltype"})
  .join(general_cells, on="celltype")
)

# Add cycle phase information
all_results['cyclephase'] = all_results['slide_id'].apply(lambda x: 'Secretory' if x in ["152807", "152811"] else 'Proliferative')

# Exclude cell types in the "Endothelial" lineage
endothelial_celltypes = general_cells[general_cells['lineage'] == 'Endothelial'].index
all_results = all_results[~all_results['celltype'].isin(endothelial_celltypes)].copy()

# Remove unused categories from categorical columns if they exist
if 'celltype' in all_results.columns and pd.api.types.is_categorical_dtype(all_results['celltype']):
    all_results['celltype'] = all_results['celltype'].cat.remove_unused_categories()
if 'lineage' in all_results.columns and pd.api.types.is_categorical_dtype(all_results['lineage']):
    all_results['lineage'] = all_results['lineage'].cat.remove_unused_categories()

# and write out the stats table for the article.qmd
all_results.to_csv(Path(data_folder).expanduser() / "st_stats_table.csv")
```


::: {.panel-tabset}

## Mid-secretory samples

For the following analysis, we will look at only the early secretory samples - 152807 and 152811.

```{python}
# some preliminary metrics
slide_ids = ["CTR1_processed_data", "CTR2_processed_data", "CTR3_processed_data", "CTR4_processed_data"]
stats_df = all_results.query("slide_id in @slide_ids").copy()
```

After running the analysis, we plot the stats. We do boxplots for the main difference between EVvsREF and BIOvsREF cases to see how the EV profiles affect the projection. And for the other metrics, we will do comparative scatter plots with the decision boundary for the correlation and for the overlap index. We separte those plots into 3 lineages, excluding the Vascular with only 2 celltypes.

Therefore, we end up with:
* Three boxplots for the MAD, Centroid Distance and Jacard index
* Pearson correlation plots for every lineage, in total 3 plots
* Finally, 2 Volcano plots with Moran's and Ripley stats

After running the analysis, we plot the stats as a line plot, comparing all the different cell types and also average them by the lineage.

```{python}
# Prep the data
plot_df_pairwise = stats_df[stats_df['comparison'].isin(['ev_vs_ref', 'bio_vs_ref'])].copy()
# Don't use some metrics that visualise later
exclude_metrics = ["Pearson Correlation"]
# Determine number of metrics for layout
col_wrap = 3

g = sns.catplot(
  data=plot_df_pairwise.query("metric not in @exclude_metrics"),
  x='lineage',     # Cell types on X
  y='value',         # Statistic value on Y
  hue='comparison',  # Color by ev_vs_ref or bio_vs_ref
  col='metric',      # Facet by metric
  kind='box',        # Use boxplots to show distribution across slides
  col_wrap=col_wrap, # Arrange facets
  sharey=False,      # IMPORTANT: Metrics have different scales
  sharex=False,      # IMPORTANT: Metrics have different scales
  height=4,          # Adjust size as needed
  aspect=1.1,        # Adjust aspect ratio
  legend_out=True
)

# Improve readability
g.set_xticklabels(rotation=90)
g.set_titles(col_template="{col_name}") # Clean titles
g.fig.suptitle('Comparison Metrics: EV vs. BIO relative to REF (across slides)', y=1.03) # Overall title
```

```{python}
metric_to_plot = 'Pearson Correlation' # Choose a metric
scatter_df = (
  plot_df_pairwise[plot_df_pairwise['metric'] == metric_to_plot]
  .pivot_table(index=['slide_id', 'celltype', 'lineage'], columns='comparison', values='value')
  .reset_index()
)
scatter_df.dropna(inplace=True) # Drop rows if one comparison is missing

# plot the data now
g = sns.FacetGrid(scatter_df, col="lineage", hue="celltype", col_wrap=3, height=4, aspect=1.1)
g.map(sns.scatterplot, "ev_vs_ref", "bio_vs_ref", alpha=0.7)

# Add y=x line for reference
for ax in g.axes.flat:
  lims = [min(ax.get_xlim()[0], ax.get_ylim()[0]), max(ax.get_xlim()[1], ax.get_ylim()[1])]
  ax.plot(lims, lims, 'k--', alpha=0.25, zorder=0, label=None)

g.set_titles(col_template="{col_name}") # Clean titles
g.fig.suptitle(f'{metric_to_plot}: EV vs REF & BIO vs REF', y=1.03) # Overall title
```

And now for the Moran's I compared to the Morans' simulated FDR (based on 1000 iterations). The Moran's I is a measure of spatial autocorrelation, and the FDR is a measure of how significant the Moran's I is compared to random distributions. We will plot the Moran's I against the FDR for each cell type and lineage, with a horizontal line at FDR = 0.05 to indicate significance.

```{python}
# Filter for Moran's I metrics
moran_df = stats_df[stats_df['metric'].isin(['Moran I', 'Moran I FDR'])].copy()

# Pivot the table to get Moran I and FDR side-by-side
moran_pivot = (
  moran_df.pivot_table(
    index=['slide_id', 'celltype', 'lineage', 'comparison'],
    columns='metric',
    values='value'
  )
  .reset_index()
  .rename_axis(None, axis=1) # Remove the 'metric' name from columns index
)

# Define a custom plotting function for each facet
def facet_scatter(data, **kwargs):
  ax = plt.gca() # Get current axis
  # Plot scatter points for the current facet's data
  sns.scatterplot(data=data, x="Moran I", y="Moran I FDR", hue="celltype",
                  alpha=0.7, ax=ax, legend=False, **kwargs) # Turn off default legend
  # Add lines connecting points of the same celltype across slides
  # Only draw lines if there are multiple points for a celltype (i.e., across slides)
  if data['celltype'].nunique() < len(data):
      sns.lineplot(
          data=data, x="Moran I", y="Moran I FDR", hue="celltype", alpha=0.3,
          units="celltype", estimator=None, sort=True, ax=ax, legend=False
      )

  # Apply axis modifications
  ax.axhline(0.05, ls='--', color='grey', alpha=0.5, zorder=0)
  ax.set_ylabel("Moran's I FDR (log scale)")
  ax.set_xlabel("Moran's I")
  ax.set_yscale('log')
  ax.invert_yaxis()

  # Manually set Y-axis ticks
  # Define desired tick values (adjust these based on your data range)
  tick_values = [1.0, 0.5, 0.2, 0.1, 0.05, 0.02, 0.01, 0.005, 0.001]
  # Create corresponding labels
  tick_labels = [str(val) for val in tick_values]

  ax.yaxis.set_major_locator(ticker.FixedLocator(tick_values))
  ax.yaxis.set_major_formatter(ticker.FixedFormatter(tick_labels))
  # Ensure y-limits accommodate the ticks if needed
  current_ylim = ax.get_ylim()
  ax.set_ylim(max(current_ylim[0], max(tick_values)*1.1), min(current_ylim[1], min(tick_values)*0.9))


  # Manually add legend to the side of each facet
  handles, labels = ax.get_legend_handles_labels()
  # Filter out potential duplicate legend entries if lineplot adds them
  unique_handles_labels = {}
  for handle, label in zip(handles, labels):
      if label not in unique_handles_labels:
          unique_handles_labels[label] = handle
  ax.legend(unique_handles_labels.values(), unique_handles_labels.keys(),
            title="Celltype", bbox_to_anchor=(1.05, 1), loc='upper left', fontsize='small')

# Create the FacetGrid instance with rows for comparison and columns for lineage
g = sns.FacetGrid(
  moran_pivot,
  row="comparison", col="lineage",
  height=3.5, aspect=1.2,
  sharey=True, sharex=False, legend_out=False,
  margin_titles=True
  ) # Add margin titles for row/col names

# Map the custom plotting function to each facet
g.map_dataframe(facet_scatter)

# Add titles and adjust layout
g.set_titles(row_template="{row_name}", col_template="{col_name}") # Set row/col titles
g.fig.suptitle("Moran's I vs. FDR by Lineage and Comparison", y=1.03) # Overall title
plt.tight_layout(rect=[0, 0, 0.9, 0.97]) # Adjust rect to prevent legend overlap
plt.show()
```

Now we can also look at the Ripley's L-function, which is a measure of spatial clustering. We will plot the Ripley's L-function AUC against the maximum p-value observed across distances for each cell type and lineage, with a horizontal line at p=0.05 to indicate significance.

```{python}
# Filter for Ripley's L metrics
ripley_df = stats_df[stats_df['metric'].isin(['Ripley L AUC', 'Ripley L Max PValue'])].copy()

# Pivot the table to get Ripley's L AUC and Max PValue side-by-side
ripley_pivot = (
  ripley_df.pivot_table(
    index=['slide_id', 'celltype', 'lineage', 'comparison'],
    columns='metric',
    values='value'
  )
  .reset_index()
  .rename_axis(None, axis=1) # Remove the 'metric' name from columns index
)

# Define a custom plotting function for each facet
def facet_scatter(data, **kwargs):
  ax = plt.gca() # Get current axis
  # Plot scatter points for the current facet's data
  sns.scatterplot(data=data, x="Ripley L AUC", y="Ripley L Max PValue", hue="celltype",
                  alpha=0.7, ax=ax, legend=False, **kwargs) # Turn off default legend
  # Add lines connecting points of the same celltype across slides
  sns.lineplot(
    data=data, x="Ripley L AUC", y="Ripley L Max PValue", hue="celltype", alpha=0.3,
    units="celltype", estimator=None, sort=True, ax=ax, legend=False
    )

  # Apply axis modifications
  ax.axhline(0.05, ls='--', color='grey', alpha=0.5, zorder=0)
  ax.set_ylabel("Ripley's L Max PValue")
  ax.set_xlabel("Ripley's L AUC")
  ax.invert_yaxis()

  # Manually add legend to the side of each facet
  handles, labels = ax.get_legend_handles_labels()
  ax.legend(handles, labels, title="Celltype", bbox_to_anchor=(1.05, 1), loc='upper left')

# Create the FacetGrid instance
g = sns.FacetGrid(ripley_pivot, col="lineage", col_wrap=3, height=4, aspect=1.1,
                  sharey=True, sharex=False, legend_out=False)

# Map the custom plotting function to each facet
g.map_dataframe(facet_scatter)

# Add titles and adjust layout
g.set_titles(col_template="{col_name}")
g.fig.suptitle("Ripley's L AUC vs. Max PValue by Lineage and Comparison", y=1.03)
plt.tight_layout(rect=[0, 0, 0.9, 0.97])
plt.show()
```

Maybe we will abandon the Ripley's L-function for now, as it is not as interpretable as the Moran's I. The Ripley's L-function is a measure of spatial clustering, but it can be difficult to interpret in terms of biological significance. The Moran's I is a more straightforward measure of spatial autocorrelation, and it is easier to interpret in terms of clustering patterns. Additionally, Ripley would be useful to look at the spatial distribution of a single cell type, but we are looking at the spatial distribution of multiple cell types in this case. The Moran's I is more appropriate for this type of analysis, as it takes into account the spatial relationships between all cell types.


## Early-secretory samples

For the following analysis, we will look at only the early secretory samples - 152807 and 152811.

```{python}
# some preliminary metrics
slide_ids = ["152807", "152811"]
stats_df = all_results.query("slide_id in @slide_ids").copy()
```

After running the analysis, we plot the stats. We do boxplots for the main difference between EVvsREF and BIOvsREF cases to see how the EV profiles affect the projection. And for the other metrics, we will do comparative scatter plots with the decision boundary for the correlation and for the overlap index. We separte those plots into 3 lineages, excluding the Vascular with only 2 celltypes.

Therefore, we end up with:
* Three boxplots for the MAD, Centroid Distance and Jacard index
* Pearson correlation plots for every lineage, in total 3 plots
* Finally, 2 Volcano plots with Moran's and Ripley stats

After running the analysis, we plot the stats as a line plot, comparing all the different cell types and also average them by the lineage.

```{python}
# Prep the data
plot_df_pairwise = stats_df[stats_df['comparison'].isin(['ev_vs_ref', 'bio_vs_ref'])].copy()
# Don't use some metrics that visualise later
exclude_metrics = ["Pearson Correlation"]
# Determine number of metrics for layout
col_wrap = 3

g = sns.catplot(
  data=plot_df_pairwise.query("metric not in @exclude_metrics"),
  x='lineage',     # Cell types on X
  y='value',         # Statistic value on Y
  hue='comparison',  # Color by ev_vs_ref or bio_vs_ref
  col='metric',      # Facet by metric
  kind='box',        # Use boxplots to show distribution across slides
  col_wrap=col_wrap, # Arrange facets
  sharey=False,      # IMPORTANT: Metrics have different scales
  sharex=False,      # IMPORTANT: Metrics have different scales
  height=4,          # Adjust size as needed
  aspect=1.1,        # Adjust aspect ratio
  legend_out=True
)

# Improve readability
g.set_xticklabels(rotation=90)
g.set_titles(col_template="{col_name}") # Clean titles
g.fig.suptitle('Comparison Metrics: EV vs. BIO relative to REF (across slides)', y=1.03) # Overall title
```

```{python}
metric_to_plot = 'Pearson Correlation' # Choose a metric
scatter_df = (
  plot_df_pairwise[plot_df_pairwise['metric'] == metric_to_plot]
  .pivot_table(index=['slide_id', 'celltype', 'lineage'], columns='comparison', values='value')
  .reset_index()
)
scatter_df.dropna(inplace=True) # Drop rows if one comparison is missing

# plot the data now
g = sns.FacetGrid(scatter_df, col="lineage", hue="celltype", col_wrap=3, height=4, aspect=1.1)
g.map(sns.scatterplot, "ev_vs_ref", "bio_vs_ref", alpha=0.7)

# Add y=x line for reference
for ax in g.axes.flat:
  lims = [min(ax.get_xlim()[0], ax.get_ylim()[0]), max(ax.get_xlim()[1], ax.get_ylim()[1])]
  ax.plot(lims, lims, 'k--', alpha=0.25, zorder=0, label=None)

g.set_titles(col_template="{col_name}") # Clean titles
g.fig.suptitle(f'{metric_to_plot}: EV vs REF & BIO vs REF', y=1.03) # Overall title
```

And now for the Moran's I compared to the Morans' simulated FDR (based on 1000 iterations). The Moran's I is a measure of spatial autocorrelation, and the FDR is a measure of how significant the Moran's I is compared to random distributions. We will plot the Moran's I against the FDR for each cell type and lineage, with a horizontal line at FDR = 0.05 to indicate significance.

```{python}
# Filter for Moran's I metrics
moran_df = stats_df[stats_df['metric'].isin(['Moran I', 'Moran I FDR'])].copy()

# Pivot the table to get Moran I and FDR side-by-side
moran_pivot = (
  moran_df.pivot_table(
    index=['slide_id', 'celltype', 'lineage', 'comparison'],
    columns='metric',
    values='value'
  )
  .reset_index()
  .rename_axis(None, axis=1) # Remove the 'metric' name from columns index
)

# Define a custom plotting function for each facet
def facet_scatter(data, **kwargs):
  ax = plt.gca() # Get current axis
  # Plot scatter points for the current facet's data
  sns.scatterplot(data=data, x="Moran I", y="Moran I FDR", hue="celltype",
                  alpha=0.7, ax=ax, legend=False, **kwargs) # Turn off default legend
  # Add lines connecting points of the same celltype across slides
  # Only draw lines if there are multiple points for a celltype (i.e., across slides)
  if data['celltype'].nunique() < len(data):
      sns.lineplot(
          data=data, x="Moran I", y="Moran I FDR", hue="celltype", alpha=0.3,
          units="celltype", estimator=None, sort=True, ax=ax, legend=False
      )

  # Apply axis modifications
  ax.axhline(0.05, ls='--', color='grey', alpha=0.5, zorder=0)
  ax.set_ylabel("Moran's I FDR (log scale)")
  ax.set_xlabel("Moran's I")
  ax.set_yscale('log')
  ax.invert_yaxis()

  # Manually set Y-axis ticks
  # Define desired tick values (adjust these based on your data range)
  tick_values = [1.0, 0.5, 0.2, 0.1, 0.05, 0.02, 0.01, 0.005, 0.001]
  # Create corresponding labels
  tick_labels = [str(val) for val in tick_values]

  ax.yaxis.set_major_locator(ticker.FixedLocator(tick_values))
  ax.yaxis.set_major_formatter(ticker.FixedFormatter(tick_labels))
  # Ensure y-limits accommodate the ticks if needed
  current_ylim = ax.get_ylim()
  ax.set_ylim(max(current_ylim[0], max(tick_values)*1.1), min(current_ylim[1], min(tick_values)*0.9))


  # Manually add legend to the side of each facet
  handles, labels = ax.get_legend_handles_labels()
  # Filter out potential duplicate legend entries if lineplot adds them
  unique_handles_labels = {}
  for handle, label in zip(handles, labels):
      if label not in unique_handles_labels:
          unique_handles_labels[label] = handle
  ax.legend(unique_handles_labels.values(), unique_handles_labels.keys(),
            title="Celltype", bbox_to_anchor=(1.05, 1), loc='upper left', fontsize='small')

# Create the FacetGrid instance with rows for comparison and columns for lineage
g = sns.FacetGrid(
  moran_pivot,
  row="comparison", col="lineage",
  height=3.5, aspect=1.2,
  sharey=True, sharex=False, legend_out=False,
  margin_titles=True
  ) # Add margin titles for row/col names

# Map the custom plotting function to each facet
g.map_dataframe(facet_scatter)

# Add titles and adjust layout
g.set_titles(row_template="{row_name}", col_template="{col_name}") # Set row/col titles
g.fig.suptitle("Moran's I vs. FDR by Lineage and Comparison", y=1.03) # Overall title
plt.tight_layout(rect=[0, 0, 0.9, 0.97]) # Adjust rect to prevent legend overlap
plt.show()
```

Now we can also look at the Ripley's L-function, which is a measure of spatial clustering. We will plot the Ripley's L-function AUC against the maximum p-value observed across distances for each cell type and lineage, with a horizontal line at p=0.05 to indicate significance.

```{python}
# Filter for Ripley's L metrics
ripley_df = stats_df[stats_df['metric'].isin(['Ripley L AUC', 'Ripley L Max PValue'])].copy()

# Pivot the table to get Ripley's L AUC and Max PValue side-by-side
ripley_pivot = (
  ripley_df.pivot_table(
    index=['slide_id', 'celltype', 'lineage', 'comparison'],
    columns='metric',
    values='value'
  )
  .reset_index()
  .rename_axis(None, axis=1) # Remove the 'metric' name from columns index
)

# Define a custom plotting function for each facet
def facet_scatter(data, **kwargs):
  ax = plt.gca() # Get current axis
  # Plot scatter points for the current facet's data
  sns.scatterplot(data=data, x="Ripley L AUC", y="Ripley L Max PValue", hue="celltype",
                  alpha=0.7, ax=ax, legend=False, **kwargs) # Turn off default legend
  # Add lines connecting points of the same celltype across slides
  sns.lineplot(
    data=data, x="Ripley L AUC", y="Ripley L Max PValue", hue="celltype", alpha=0.3,
    units="celltype", estimator=None, sort=True, ax=ax, legend=False
    )

  # Apply axis modifications
  ax.axhline(0.05, ls='--', color='grey', alpha=0.5, zorder=0)
  ax.set_ylabel("Ripley's L Max PValue")
  ax.set_xlabel("Ripley's L AUC")
  ax.invert_yaxis()

  # Manually add legend to the side of each facet
  handles, labels = ax.get_legend_handles_labels()
  ax.legend(handles, labels, title="Celltype", bbox_to_anchor=(1.05, 1), loc='upper left')

# Create the FacetGrid instance
g = sns.FacetGrid(ripley_pivot, col="lineage", col_wrap=3, height=4, aspect=1.1,
                  sharey=True, sharex=False, legend_out=False)

# Map the custom plotting function to each facet
g.map_dataframe(facet_scatter)

# Add titles and adjust layout
g.set_titles(col_template="{col_name}")
g.fig.suptitle("Ripley's L AUC vs. Max PValue by Lineage and Comparison", y=1.03)
plt.tight_layout(rect=[0, 0, 0.9, 0.97])
plt.show()
```

Maybe we will abandon the Ripley's L-function for now, as it is not as interpretable as the Moran's I. The Ripley's L-function is a measure of spatial clustering, but it can be difficult to interpret in terms of biological significance. The Moran's I is a more straightforward measure of spatial autocorrelation, and it is easier to interpret in terms of clustering patterns. Additionally, Ripley would be useful to look at the spatial distribution of a single cell type, but we are looking at the spatial distribution of multiple cell types in this case. The Moran's I is more appropriate for this type of analysis, as it takes into account the spatial relationships between all cell types.

## Proliferative samples

For the following analysis, we will look at only the early secretory samples - 152806 and 152810.

```{python}
# some preliminary metrics
slide_ids = ["152806", "152810"]
stats_df = all_results.query("slide_id in @slide_ids").copy()
```

After running the analysis, we plot the stats. We do boxplots for the main difference between EVvsREF and BIOvsREF cases to see how the EV profiles affect the projection. And for the other metrics, we will do comparative scatter plots with the decision boundary for the correlation and for the overlap index. We separte those plots into 3 lineages, excluding the Vascular with only 2 celltypes.

Therefore, we end up with:
* Three boxplots for the MAD, Centroid Distance and Jacard index
* Pearson correlation plots for every lineage, in total 3 plots
* Finally, 2 Volcano plots with Moran's and Ripley stats

After running the analysis, we plot the stats as a line plot, comparing all the different cell types and also average them by the lineage.

```{python}
# Prep the data
plot_df_pairwise = stats_df[stats_df['comparison'].isin(['ev_vs_ref', 'bio_vs_ref'])].copy()
# Don't use some metrics that visualise later
exclude_metrics = ["Pearson Correlation"]
# Determine number of metrics for layout
col_wrap = 3

g = sns.catplot(
  data=plot_df_pairwise.query("metric not in @exclude_metrics"),
  x='lineage',     # Cell types on X
  y='value',         # Statistic value on Y
  hue='comparison',  # Color by ev_vs_ref or bio_vs_ref
  col='metric',      # Facet by metric
  kind='box',        # Use boxplots to show distribution across slides
  col_wrap=col_wrap, # Arrange facets
  sharey=False,      # IMPORTANT: Metrics have different scales
  sharex=False,      # IMPORTANT: Metrics have different scales
  height=4,          # Adjust size as needed
  aspect=1.1,        # Adjust aspect ratio
  legend_out=True
)

# Improve readability
g.set_xticklabels(rotation=90)
g.set_titles(col_template="{col_name}") # Clean titles
g.fig.suptitle('Comparison Metrics: EV vs. BIO relative to REF (across slides)', y=1.03) # Overall title
```

```{python}
metric_to_plot = 'Pearson Correlation' # Choose a metric
scatter_df = (
  plot_df_pairwise[plot_df_pairwise['metric'] == metric_to_plot]
  .pivot_table(index=['slide_id', 'celltype', 'lineage'], columns='comparison', values='value')
  .reset_index()
)
scatter_df.dropna(inplace=True) # Drop rows if one comparison is missing

# plot the data now
g = sns.FacetGrid(scatter_df, col="lineage", hue="celltype", col_wrap=3, height=4, aspect=1.1)
g.map(sns.scatterplot, "ev_vs_ref", "bio_vs_ref", alpha=0.7)

# Add y=x line for reference
for ax in g.axes.flat:
  lims = [min(ax.get_xlim()[0], ax.get_ylim()[0]), max(ax.get_xlim()[1], ax.get_ylim()[1])]
  ax.plot(lims, lims, 'k--', alpha=0.25, zorder=0, label=None)

g.set_titles(col_template="{col_name}") # Clean titles
g.fig.suptitle(f'{metric_to_plot}: EV vs REF & BIO vs REF', y=1.03) # Overall title
```

And now for the Moran's I compared to the Morans' simulated FDR (based on 1000 iterations). The Moran's I is a measure of spatial autocorrelation, and the FDR is a measure of how significant the Moran's I is compared to random distributions. We will plot the Moran's I against the FDR for each cell type and lineage, with a horizontal line at FDR = 0.05 to indicate significance.

```{python}
# Filter for Moran's I metrics
moran_df = stats_df[stats_df['metric'].isin(['Moran I', 'Moran I FDR'])].copy()

# Pivot the table to get Moran I and FDR side-by-side
moran_pivot = (
  moran_df.pivot_table(
    index=['slide_id', 'celltype', 'lineage', 'comparison'],
    columns='metric',
    values='value'
  )
  .reset_index()
  .rename_axis(None, axis=1) # Remove the 'metric' name from columns index
)

# Define a custom plotting function for each facet
def facet_scatter(data, **kwargs):
  ax = plt.gca() # Get current axis
  # Plot scatter points for the current facet's data
  sns.scatterplot(data=data, x="Moran I", y="Moran I FDR", hue="celltype",
                  alpha=0.7, ax=ax, legend=False, **kwargs) # Turn off default legend
  # Add lines connecting points of the same celltype across slides
  # Only draw lines if there are multiple points for a celltype (i.e., across slides)
  if data['celltype'].nunique() < len(data):
      sns.lineplot(
          data=data, x="Moran I", y="Moran I FDR", hue="celltype", alpha=0.3,
          units="celltype", estimator=None, sort=True, ax=ax, legend=False
      )

  # Apply axis modifications
  ax.axhline(0.05, ls='--', color='grey', alpha=0.5, zorder=0)
  ax.set_ylabel("Moran's I FDR (log scale)")
  ax.set_xlabel("Moran's I")
  ax.set_yscale('log')
  ax.invert_yaxis()

  # Manually set Y-axis ticks
  # Define desired tick values (adjust these based on your data range)
  tick_values = [1.0, 0.5, 0.2, 0.1, 0.05, 0.02, 0.01, 0.005, 0.001]
  # Create corresponding labels
  tick_labels = [str(val) for val in tick_values]

  ax.yaxis.set_major_locator(ticker.FixedLocator(tick_values))
  ax.yaxis.set_major_formatter(ticker.FixedFormatter(tick_labels))
  # Ensure y-limits accommodate the ticks if needed
  current_ylim = ax.get_ylim()
  ax.set_ylim(max(current_ylim[0], max(tick_values)*1.1), min(current_ylim[1], min(tick_values)*0.9))


  # Manually add legend to the side of each facet
  handles, labels = ax.get_legend_handles_labels()
  # Filter out potential duplicate legend entries if lineplot adds them
  unique_handles_labels = {}
  for handle, label in zip(handles, labels):
      if label not in unique_handles_labels:
          unique_handles_labels[label] = handle
  ax.legend(unique_handles_labels.values(), unique_handles_labels.keys(),
            title="Celltype", bbox_to_anchor=(1.05, 1), loc='upper left', fontsize='small')

# Create the FacetGrid instance with rows for comparison and columns for lineage
g = sns.FacetGrid(
  moran_pivot,
  row="comparison", col="lineage",
  height=3.5, aspect=1.2,
  sharey=True, sharex=False, legend_out=False,
  margin_titles=True # Add margin titles for row/col names
  )

# Map the custom plotting function to each facet
g.map_dataframe(facet_scatter)

# Add titles and adjust layout
g.set_titles(row_template="{row_name}", col_template="{col_name}") # Set row/col titles
g.fig.suptitle("Moran's I vs. FDR by Lineage and Comparison", y=1.03) # Overall title
plt.tight_layout(rect=[0, 0, 0.9, 0.97]) # Adjust rect to prevent legend overlap
plt.show()
```

Now we can also look at the Ripley's L-function, which is a measure of spatial clustering. We will plot the Ripley's L-function AUC against the maximum p-value observed across distances for each cell type and lineage, with a horizontal line at p=0.05 to indicate significance.

```{python}
# Filter for Ripley's L metrics
ripley_df = stats_df[stats_df['metric'].isin(['Ripley L AUC', 'Ripley L Max PValue'])].copy()

# Pivot the table to get Ripley's L AUC and Max PValue side-by-side
ripley_pivot = (
  ripley_df.pivot_table(
    index=['slide_id', 'celltype', 'lineage', 'comparison'],
    columns='metric',
    values='value'
  )
  .reset_index()
  .rename_axis(None, axis=1) # Remove the 'metric' name from columns index
)

# Define a custom plotting function for each facet
def facet_scatter(data, **kwargs):
  ax = plt.gca() # Get current axis
  # Plot scatter points for the current facet's data
  sns.scatterplot(data=data, x="Ripley L AUC", y="Ripley L Max PValue", hue="celltype",
                  alpha=0.7, ax=ax, legend=False, **kwargs) # Turn off default legend
  # Add lines connecting points of the same celltype across slides
  sns.lineplot(
    data=data, x="Ripley L AUC", y="Ripley L Max PValue", hue="celltype", alpha=0.3,
    units="celltype", estimator=None, sort=True, ax=ax, legend=False
    )

  # Apply axis modifications
  ax.axhline(0.05, ls='--', color='grey', alpha=0.5, zorder=0)
  ax.set_ylabel("Ripley's L Max PValue")
  ax.set_xlabel("Ripley's L AUC")
  ax.invert_yaxis()

  # Manually add legend to the side of each facet
  handles, labels = ax.get_legend_handles_labels()
  ax.legend(handles, labels, title="Celltype", bbox_to_anchor=(1.05, 1), loc='upper left')

# Create the FacetGrid instance
g = sns.FacetGrid(ripley_pivot, col="lineage", col_wrap=3, height=4, aspect=1.1,
                  sharey=True, sharex=False, legend_out=False)

# Map the custom plotting function to each facet
g.map_dataframe(facet_scatter)

# Add titles and adjust layout
g.set_titles(col_template="{col_name}")
g.fig.suptitle("Ripley's L AUC vs. Max PValue by Lineage and Comparison", y=1.03)
plt.tight_layout(rect=[0, 0, 0.9, 0.97])
plt.show()
```

Maybe we will abandon the Ripley's L-function for now, as it is not as interpretable as the Moran's I. The Ripley's L-function is a measure of spatial clustering, but it can be difficult to interpret in terms of biological significance. The Moran's I is a more straightforward measure of spatial autocorrelation, and it is easier to interpret in terms of clustering patterns. Additionally, Ripley would be useful to look at the spatial distribution of a single cell type, but we are looking at the spatial distribution of multiple cell types in this case. The Moran's I is more appropriate for this type of analysis, as it takes into account the spatial relationships between all cell types.

:::

# Look at specific gene expression profiles in spatial transcriptomic slides

From Elina:

>Tšau,
>
>Ma oletan, et äkki näeme strooma rakke projitseerituna müomeetriumi, sest seal võivad reaalselt olla fibroblastid.
>
>Leidsin selle artikli: https://academic.oup.com/molehr/article/20/3/250/1114116
>
>Kas sa saaksid vaadata, kas need "strooma rakud" mis asuvad müomeetriumis ekspresseerivad geene CD90, ALDH1A1, ALDH1A2, ALDH1A3, ALDH1B1?
>
>Tervitades,
>
>Elina

First let's project the abundances of the stromal cell types on the slide with the scRNA-seq data. We are using slide with id 152807 (Early-Secretory)

::: {.panel-tabset}
## Reference
```{python}
vis_dat = adata_collection[("152807", "ref")].copy()
sq.pl.spatial_scatter(vis_dat, cmap='magma', ncols=2,
  color=vis_dat.obs.columns[vis_dat.obs.columns.str.contains("stroma", case=False)])
```
## EV
```{python}
vis_dat = adata_collection[("152807", "ev")].copy()
sq.pl.spatial_scatter(vis_dat, cmap='magma', ncols=2,
  color=vis_dat.obs.columns[vis_dat.obs.columns.str.contains("stroma", case=False)])
```
## Biopsy
```{python}
vis_dat = adata_collection[("152807", "bio")].copy()
sq.pl.spatial_scatter(vis_dat, cmap='magma', ncols=2,
  color=vis_dat.obs.columns[vis_dat.obs.columns.str.contains("stroma", case=False)])
```
:::

Then we look at specific gene expression profiles in the slide, the genes were interested in are CD90, ALDH1A1, ALDH1A2, ALDH1A3, ALDH1B1. CD90 does not seem to be in the dataset, mightve been filtered out via the highly variable gene filtering or it has an alternative name here. We do have an aliased genes for the CD90, the THY1.

For this view, we do not to look at different projections, as we are looking at the expression of the genes in the original spatial transcrpitomic slide itself.

```{python}
slide_id = "152807"
vis_dat = adata_collection[("152807", "ref")].copy()
genes_of_interest = ["THY1", "ALDH1A1", "ALDH1A2", "ALDH1A3", "ALDH1B1"]
# the original unfiltered slide is stored within the ".raw" object
sq.pl.spatial_scatter(vis_dat, use_raw=True, cmap='magma', ncols=2, color=genes_of_interest)
```

In addition, lets look at some EV biomarker genes as well.

```{python}
## Create a dictionary of all the genes we want to plot, and then go per key
all_genes = {
  "ESCRT-0": ["HGS", "STAM", "STAM2"],
  "ESCRT-I": ["MVB12A", "MVB12B", "TSG101", "UBAP1", "VPS28", "VPS37A", "VPS37B", "VPS37C", "VPS37D"],
  "ESCRT-II": ["SNF8", "VPS25", "VPS36"],
  "ESCRT-III": ["CHMP2A", "CHMP2B", "CHMP3", "CHMP4A", "CHMP4B", "CHMP4C", "CHMP6"],
  "ESCRT-IV": ["VPS4A","VPS4B","VTA1"],
  "ESCRT-independent": ["RAB31", "SMPD3"],
  "EV release gene markers": ["RAB27A", "RAB27B", "RAB11A", "RAB11B", "RAB3A", "RAB3B", "RAB3C", "RAB3D", "RAB7A", "RAB7B"],
  "tetraspanins": ["CD9", "CD63", "CD81", "ALIX", "SDCBP"],
  "accessory": ["PDCD6IP", "SDCBP", "SDC1", "SDC2", "SDC3", "SDC4"]
}
```

```{python}
for gene_group in all_genes.keys():
  print(f"All genes in group: {gene_group}")
  tmp_dat = vis_dat.raw
  genes_of_interest = all_genes[gene_group]
  genes_of_interest = np.intersect1d(genes_of_interest, tmp_dat.var_names.tolist())
  # the original unfiltered slide is stored within the ".raw" object
  sq.pl.spatial_scatter(vis_dat, use_raw=True, cmap='magma', ncols=2, color=genes_of_interest.tolist())
```

# Correlation between cell profile and EV biomarkers

Here we are interested in the correlation between the expression of EV biomarkers and the cell profiles in the spatial transcriptomic data. This can help us understand how different cell types contribute to EV production and release in the tissue context.

```{python}



```