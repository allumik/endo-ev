---
title: "Single cell perspective into Extracellular Vesicules projected onto Spatial Transcriptomics"
execute:
  keep-ipynb: true
format:
  html:
    code-fold: true
    code-tools: true
    embed-resources: true
    self-contained-math: true
jupyter: python3
---

# Load in data

Set up the environment and load the deps:

```{python}
#| output: false

import re
import os
import glob
import warnings
import pandas as pd
import numpy as np
import scanpy as sc
import squidpy as sq
import anndata as an
from pathlib import Path
from dotenv import load_dotenv
from scipy.sparse import csr_matrix

# pd.set_option('display.max_columns', 100)

## import the functions used in this report (got too long to include them in the report)
try: from analysis.helpers.projection_functions import *
except ImportError: from helpers.projection_functions import *

## load the environment variables from the .env file
load_dotenv()
if os.getenv("DATA_FOLDER") is None:
  load_dotenv(Path.cwd() / ".env")

anndata_folder = os.getenv("ANNDATA_FOLDER")
atlas_folder = os.getenv("ATLAS_FOLDER")
data_folder = os.getenv("DATA_FOLDER")
st_folder = os.getenv("ST_FOLDER")
model_folder = Path(data_folder).expanduser() / "saved_models"
raw_data_folder = os.getenv("RAW_DATA_FOLDER")

```

Load in the data, filter out "Hormones" celltypes and non-endometriotic samples and finally do some preprocessing:

```{python}
#| output: false

## load in the modified HECA atlas
snapshot_an_loc = Path(data_folder).expanduser() / "sc_deconv_snapshot.h5ad"
sc_dat = an.read_h5ad(snapshot_an_loc)
general_cells = ( # associate celltypes with the lineage information in the sc_dat.obs
  sc_dat.obs
  .loc[:, ["lineage", "celltype"]]
  .drop_duplicates("celltype")
  .set_index("celltype", drop=True)
)

## load in the EV CCHT only data and drop the "none" gene id in the end
ccht_uf_raw = pd.read_feather(Path(data_folder).expanduser() / "filtered" / "annot_raw.feather").set_index("gene_id").iloc[:-1]
ccht_uf_pheno = pd.read_table(Path(data_folder).expanduser() / "filtered" / "phenotype.tsv").set_index("samplename")
## Filter out some samples that are not behaving very well...
terminator = ["HUT26_UF", "HUT26_biopsy"]
ccht_uf_pheno = ccht_uf_pheno.query("samplename not in @terminator")
ccht_uf_raw = ccht_uf_raw.drop(columns=terminator)

```

Load in the spatial slides experiments

```{python}

slides_path = Path(st_folder).expanduser()
anndata_path = Path(anndata_folder).expanduser() # Ensure anndata_folder is a Path object
vis_dats = {}
for vis_fold in slides_path.iterdir():
  if vis_fold.is_dir():
    slide_id = vis_fold.stem
    expected_file = anndata_path / f"st_slide_{slide_id}.h5ad"
    try:
      vis_dat = an.read_h5ad(expected_file)
      vis_dats[slide_id] = vis_dat
    except FileNotFoundError:
      print(f"Warning: AnnData file not found for slide '{slide_id}'. Skipping.")
    except Exception as e:
      print(f"Error reading AnnData file for slide '{slide_id}': {e}")

vis_keys = list(vis_dats.keys())

```

# Bulk deconvolution and projection onto single cells

We'd be interested in using scRNA-seq atlas to deconvolve the EV data. This helps us understand where are those EV produced and which tissue signal they are capturing. To run single cell and projection, we are gonna use [TAPE](https://www.nature.com/articles/s41467-022-34550-9) algorithm. This algorithm also enables us to use the trained VAE model to estimate the number and the distribution of original cell populations.

First we'll need to reformat the raw bulk RNA samples from EV to matrix form and prepare some plotting functions.

Train the model on the single cell reference data and generate the pseudo-single-cell data from the bulk samples. Here we divide the original dataset into "biopsy" and "EV" groups, which then summarises all of the corresponding sampling method samples into one representative group. This would also increase the confidence of cell profiles while normalising individual variance.

::: {.panel-tabset}

## EV group

```{python}

gen_sc_file = Path(anndata_folder).expanduser() / "gen_sc_ev.h5ad"
gen_ccht_ev = sc.read_h5ad(gen_sc_file, backed="r").to_memory()

```

The generated dataset is then preprocessed, scaled, embedded into lower dimensions and clustered via Leiden. The visualisation is done using celltype annotation from HECA

```{python}

sc.pl.embedding(
  gen_ccht_ev,
  basis='X_pca',
  color='celltype',
  frameon='small'
)

sc.pl.embedding(
  gen_ccht_ev,
  basis='X_umap',
  color='celltype',
  frameon='small'
)

sc.pl.embedding(
  gen_ccht_ev,
  basis='X_umap',
  color='lineage',
  frameon='small'
)

```

## Biopsy group

```{python}

gen_sc_file = Path(anndata_folder).expanduser() / "gen_sc_biopsy.h5ad"
gen_ccht_bio = sc.read_h5ad(gen_sc_file, backed="r").to_memory()

```

The generated dataset is then preprocessed, scaled, embedded into lower dimensions and clustered via Leiden.

```{python}

sc.pl.embedding(
  gen_ccht_bio,
  basis='X_pca',
  color='celltype',
  frameon='small'
)

sc.pl.embedding(
  gen_ccht_bio,
  basis='X_umap',
  color='celltype',
  frameon='small'
)

sc.pl.embedding(
  gen_ccht_bio,
  basis='X_umap',
  color='lineage',
  frameon='small'
)

```

:::


# Projection of generated counts to Spatial Transcriptomic slides

And now use the generated pseudo-single-cell dataset and project it to the spatial transcriptomic slide.

First we will go with the early secretory stage samples

::: {.panel-tabset}

```{python}
# set the exemplary sample to use for downstream tasks
example_sample = "152807" # "E184-1_bottom"
```

{{< include ev2space_slide.qmd >}}

```{python}
# set the exemplary sample to use for downstream tasks
example_sample = "152811" # "E184-1_bottom"
```

{{< include ev2space_slide.qmd >}}

:::

Then let's also look at the proliferative stage samples

::: {.panel-tabset}

```{python}
# set the exemplary sample to use for downstream tasks
example_sample = "152806" # "E184-1_bottom"
```

{{< include ev2space_slide.qmd >}}

```{python}
# set the exemplary sample to use for downstream tasks
example_sample = "152810" # "E184-1_bottom"
```

{{< include ev2space_slide.qmd >}}

:::

# Calculate summary statistics for the ST slides

Here we try to quantify the difference in distances of different enrichment signatures. For this, we calculate the following statistics:

* Per cell type over all the slides
  * Simple absolute difference of enrichment per spot
  * Correlation between slides via `scipy.signal.correlate2d`
  * Apply 2D filtering and then calculate the average distance to enrichment cluster on another projection
    * Try either mean or max filtering for the most enriched cell type
* General clustering statistics over all the slide
  * Moran's I which indicates the strength of clustering, here applied on celltype abundances with the `squidpy.gr.spatial_autocorr` function
  * Ripley's K-function on the maximum enrichment cell type, calculated via `squidpy.gr.ripley`
  * Jaccard Index compared to the `ref` slide after filtering enrichment scores with a lower quartile threshold
  * Total distance (Wasserstein distance?) per celltype over the whole slide per celltype

For the filtering step we wish to remove any lowly enriched clusters so that only the more highly expressed features are left. This step is also applied before the multiclass plots so that the lowly enriched values wouldnt affect the other cell types. The lowly enriched region filtering is performed via a simple thresholding approach where the threshold is the lower quartile of the distribution over the slide for the cell type.

In addition, we have subset some of the more niche celltypes that either don't exhibit a patterns in expression or are not related to the current cycle phase.

```{python}

# Function to load AnnData objects from a directory
def load_spatial_data(data_dir, pattern="c2l_*.h5ad"):
  """Loads AnnData objects matching the pattern."""
  data_dict = {}
  file_paths = glob.glob(os.path.join(data_dir, pattern))
  print(file_paths)
  if not file_paths:
    warnings.warn(f"No files found matching pattern '{pattern}' in directory '{data_dir}'")
    return data_dict

  for file_path in file_paths:
    file_name = os.path.basename(file_path)
    match = re.match(r"c2l_(\d*?)_(ev|bio|ref)\.h5ad", file_name)
    if match:
      slide_id = match.group(1)
      ref_type = match.group(2)
      try:
        adata = sc.read_h5ad(file_path, backed="r").to_memory()

        # Ensure consistent cell type order for comparisons later
        adata = adata[:, sorted(adata.var_names)].copy()

        data_dict[(slide_id, ref_type)] = adata
      except Exception as e:
        warnings.warn(f"Could not load or process {file_name}: {e}")
    else:
        warnings.warn(f"Filename {file_name} did not match expected pattern.")

  return data_dict


# Load the data
data_directory = Path(anndata_folder).expanduser() # Current directory, adjust as needed
# load only the early secretory samples
adata_collection = load_spatial_data(data_directory)

```

::: {.panel-tabset}

## Early-secretory samples

For the following analysis, we will look at only the early secretory samples - 152807 and 152811.

```{python}
## Run the functions on the dataset
# some preliminary metrics
jaccard_thresh = 0.25 # Use lower quartile for Jaccard and Centroid distance
slide_ids = ["152807", "152811"]

# Process each slide
all_results = []
for slide_id in slide_ids:
  print(f"Processing slide: {slide_id}")

  # Calculate Spatial Graph (once per slide, using ref adata)
  # Ensure graph calculation works even if previously calculated
  # Use generic coord_type for flexibility if not strictly Visium grid
  metricses = []
  for datatype in ["ref", "ev", "bio"]:
    # get it from the collection
    current_dataset = adata_collection.get((slide_id, datatype))
    sq.gr.spatial_neighbors(
      current_dataset, 
      coord_type="generic", 
      spatial_key="spatial", 
      key_added="spatial"
    )
    # and set it to the collection
    adata_collection[(slide_id, datatype)] = current_dataset

    # Calculate Single-Adata Metrics (Moran's I)
    metrics_df = calculate_single_adata_metrics(current_dataset)
    metricses.append(metrics_df)

  single_metrics = pd.concat(metricses, ignore_index=True)
  single_metrics['slide_id'] = slide_id
  single_metrics['comparison'] = 'within_reference' # Indicate these are not pairwise comparisons
  all_results.append(single_metrics)

  # Calculate Pairwise Comparison Metrics for different comparisions
  comp_metrics_ev_vs_ref = calculate_comparison_metrics(
    adata_collection.get((slide_id, "ref")),
    adata_collection.get((slide_id, "ev")),
    jaccard_thresh
  )
  comp_metrics_ev_vs_ref['slide_id'] = slide_id
  comp_metrics_ev_vs_ref['comparison'] = 'ev_vs_ref'
  all_results.append(comp_metrics_ev_vs_ref)

  comp_metrics_bio_vs_ref = calculate_comparison_metrics(
    adata_collection.get((slide_id, "ref")),
    adata_collection.get((slide_id, "bio")),
    jaccard_thresh
  )
  comp_metrics_bio_vs_ref['slide_id'] = slide_id
  comp_metrics_bio_vs_ref['comparison'] = 'bio_vs_ref'
  all_results.append(comp_metrics_bio_vs_ref)

# Combine all results into a single DataFrame and add lineage mapping
stats_df = (
  pd.concat(all_results, ignore_index=True)
  .rename(columns={"cell_type": "celltype"})
  .join(general_cells, on="celltype")
)
```

After running the analysis, we plot the stats as a line plot, comparing all the different cell types and also average them by the lineage.

```{python}
# Prep the data
plot_df_pairwise = stats_df[stats_df['comparison'].isin(['ev_vs_ref', 'bio_vs_ref'])].copy()
# Don't use some metrics that visualise later
exclude_metrics = ["Pearson Correlation"]
# Determine number of metrics for layout
col_wrap = 2

g = sns.catplot(
  data=plot_df_pairwise.query("metric not in @exclude_metrics"),
  x='lineage',     # Cell types on X
  y='value',         # Statistic value on Y
  hue='comparison',  # Color by ev_vs_ref or bio_vs_ref
  col='metric',      # Facet by metric
  kind='box',        # Use boxplots to show distribution across slides
  col_wrap=col_wrap, # Arrange facets
  sharey=False,      # IMPORTANT: Metrics have different scales
  sharex=False,      # IMPORTANT: Metrics have different scales
  height=4,          # Adjust size as needed
  aspect=1.1,        # Adjust aspect ratio
  legend_out=True
)

# Improve readability
g.set_xticklabels(rotation=90)
g.set_titles(col_template="{col_name}") # Clean titles
g.fig.suptitle('Comparison Metrics: EV vs. BIO relative to REF (across slides)', y=1.03) # Overall title
```

```{python}
metric_to_plot = 'Pearson Correlation' # Choose a metric
scatter_df = (
  plot_df_pairwise[plot_df_pairwise['metric'] == metric_to_plot]
  .pivot_table(index=['slide_id', 'celltype', 'lineage'], columns='comparison', values='value')
  .reset_index()
)
scatter_df.dropna(inplace=True) # Drop rows if one comparison is missing
```

```{python}
<<<<<<< HEAD
sq.pl.spatial_scatter(
  vis_dat_ev,
  color=signf_ct,
  spatial_key="spatial",
  shape="hex",
  img=False
)
=======
plt.figure(figsize=(7, 7))
sns.scatterplot(data=scatter_df, x='ev_vs_ref', y='bio_vs_ref', hue='celltype', s=50, alpha=0.7)

# Add y=x line for reference
lims = [min(plt.xlim()[0], plt.ylim()[0]), max(plt.xlim()[1], plt.ylim()[1])]
plt.plot(lims, lims, 'k--', alpha=0.25, zorder=0, label=None)

plt.title(f'{metric_to_plot}: EV vs REF & BIO vs REF')
plt.xlabel(f'{metric_to_plot} (EV vs REF)')
plt.ylabel(f'{metric_to_plot} (BIO vs REF)')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', title='Cell Type')
plt.grid(True, ls='--', alpha=0.5)
plt.show()
```

```{python}
metric_to_plot = f'Jaccard Index (>{round(jaccard_thresh*100)}%)' # Choose a metric
scatter_df = (
  plot_df_pairwise[plot_df_pairwise['metric'] == metric_to_plot]
  .pivot_table(index=['slide_id', 'celltype', 'lineage'], columns='comparison', values='value')
  .reset_index()
)
scatter_df.dropna(inplace=True) # Drop rows if one comparison is missing
```

```{python}
plt.figure(figsize=(7, 7))
sns.scatterplot(data=scatter_df, x='ev_vs_ref', y='bio_vs_ref', hue='lineage', s=50, alpha=0.7)

# Add y=x line for reference
lims = [min(plt.xlim()[0], plt.ylim()[0]), max(plt.xlim()[1], plt.ylim()[1])]
plt.plot(lims, lims, 'k--', alpha=0.25, zorder=0, label=None)

plt.title(f'{metric_to_plot}: EV vs REF & BIO vs REF')
plt.xlabel(f'{metric_to_plot} (EV vs REF)')
plt.ylabel(f'{metric_to_plot} (BIO vs REF)')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', title='Cell Type')
plt.grid(True, ls='--', alpha=0.5)
plt.show()
```

## Proliferative samples

For the following analysis, we will look at only the early secretory samples - 152807 and 152811.

:::

# Look at specific gene expression profiles in spatial transcriptomic slides

From Elina:

>Tšau,
>
>Ma oletan, et äkki näeme strooma rakke projitseerituna müomeetriumi, sest seal võivad reaalselt olla fibroblastid.
>
>Leidsin selle artikli: https://academic.oup.com/molehr/article/20/3/250/1114116
>
>Kas sa saaksid vaadata, kas need "strooma rakud" mis asuvad müomeetriumis ekspresseerivad geene CD90, ALDH1A1, ALDH1A2, ALDH1A3, ALDH1B1?
>
>Tervitades,
>
>Elina

First let's project the abundances of the stromal cell types on the slide with the scRNA-seq data. We are using slide with id 152807 (Early-Secretory)

::: {.panel-tabset}
## Reference
```{python}
vis_data = adata_collection[("152807", "ref")].copy()
sq.pl.spatial_scatter(vis_data, cmap='magma', ncols=2,
  color=vis_data.obs.columns[vis_data.obs.columns.str.contains("stroma", case=False)])
```
## EV
```{python}
vis_data = adata_collection[("152807", "ev")].copy()
sq.pl.spatial_scatter(vis_data, cmap='magma', ncols=2,
  color=vis_data.obs.columns[vis_data.obs.columns.str.contains("stroma", case=False)])
>>>>>>> fb1c9f75019b96d7bd07921a258929fb1702c086
```
## Biopsy
```{python}
vis_data = adata_collection[("152807", "bio")].copy()
sq.pl.spatial_scatter(vis_data, cmap='magma', ncols=2,
  color=vis_data.obs.columns[vis_data.obs.columns.str.contains("stroma", case=False)])
```
:::

Then we look at specific gene expression profiles in the slide, the genes were interested in are CD90, ALDH1A1, ALDH1A2, ALDH1A3, ALDH1B1. CD90 does not seem to be in the dataset, mightve been filtered out via the highly variable gene filtering or it has an alternative name here. We do have an aliased genes for the CD90, the THY1.

For this view, we do not to look at different projections, as we are looking at the expression of the genes in the original spatial transcrpitomic slide itself.

```{python}
slide_id = "152807"
vis_data = adata_collection[("152807", "ref")].copy()
genes_of_interest = ["THY1", "ALDH1A1", "ALDH1A2", "ALDH1A3", "ALDH1B1"]
# the original unfiltered slide is stored within the ".raw" object
sq.pl.spatial_scatter(vis_data, use_raw=True, cmap='magma', ncols=2, color=genes_of_interest)
```
